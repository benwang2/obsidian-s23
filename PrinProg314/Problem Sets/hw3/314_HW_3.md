---
title: Assignment 3
course: CS_314
released: YYYY-MM-DD
due: 2023-02-21
tags:
- Assignments
- CS_314
---
<center><h1>Assignment 3</h1></center>
<center><h3>CS314</h3></center>
## 1 Problem â€” LL(1) Recursive Descent Parsing

$$\begin{align}
\text{<program>}::=\;&\text{prog<block>} .\\
\text{<block>} ::=\;&\text{begin <stmtlist> end}\\
\text{<stmtlist>} ::=\;&\text{<stmt> <morestmts>}\\
\text{<morestmts>} ::=\;&\text{; <stmtlist>} | \epsilon \\
\text{<stmt>} ::=\;&\text{<assign>} | \text{<ifstmt>} | \\
&\text{<repeatstmt>}|\text{<block>}\\
\text{<assign>} ::=\;&\text{<var>} = \text{<expr>} \\
\text{<ifstmt>} ::=\;&\text{if <testexpr> then <stmt> else <stmt>} \\
\text{<repeatstmt>} ::=\;&\text{repeat <stmt> until <testexpr>} \\
\text{<testexpr>} ::=\;&\text{<var>}<=\text{<expr>} \\
\text{<expr>} ::=\;&+\text{<expr> <expr>} | \\
&-\text{<expr> <expr>}|\\
&*\text{<expr> <expr>}|\\
&\text{<var>} | \text{<digit>} \\
\text{<var>} ::=\;&\text{a | b | c} \\
\text{<digit>} ::=\;&\text{0 | 1 | 2}
\end{align}$$

1. Show that the grammar above is LL(1). Use a formal argument based on the definition of the LL(1) property.

> 	**A grammar is LL(1)**  if and only if $(A ::= \alpha \text{ and } A ::= \beta)$ implies
> 		$FIRST^+(\alpha) \cap FIRST^+(\beta) = \emptyset$

FIRST(prog \<block\> .) = {prog}
FIRST(begin \<stmtlist\> end) = {begin}
FIRST(\<stmt\> \<morestmts\>) = {a, b, c, if, repeat, begin}
FIRST(; \<stmtlist\> | $\epsilon$) = {;, $\epsilon$}
FIRST(\<stmt\>) = {a,b,c, if, repeat, begin}
FIRST(\<var\> = \<expr\>) = {a, b, c}
FIRST(\<ifstmt\>) = {if}
FIRST(\<repeatstmt\>) = {repeat}
FIRST(\<var\> <= \<expr\>) = {a,b,c}
FIRST(\<expr\>) = {+, -, \*, a, b, c, 0, 1, 2}

FOLLOW(\<program\>) = {end}
FOLLOW(\<block\>) = {., until, else, ;, end}
FOLLOW(\<stmtlist\>) = {end}
FOLLOW(\<morestmts\>) = {end}
FOLLOW(\<stmt\>) = {;, else, until, $\epsilon$}
FOLLOW(\<assign\>) = {;, else, until, end, $\epsilon$}
FOLLOW(\<ifstmt\>) = {;, else, until, end, $\epsilon$}
FOLLOW(\<repeatstmt\>) = {;, else, until, end, $\epsilon$}
FOLLOW(\<testexpr\>) = {;, until, then, else, end}
FOLLOW(\<expr\>) = {+, -, \*, a, b, c, 0, 1, 2, then, until, else, end, ;}
FOLLOW(\<var\>) = {<=, =,+, -, \*, a, b, c, 0, 1, 2, then, until, else, end, ;}
FOLLOW(\<digit\>) = {+, -, \*, a, b, c, 0, 1, 2, then, until, else, end, ;}

In simple terms, a grammar is LL(1) if and only if, for all rules that have different derivations, have different FIRST sets and consequently, deterministic. The intersection of the different derivations of a rule must be the empty set in order for our grammar to be LL(1).

We must prove this for each rule that has different derivations, e.g.:
1. \<morestmts\>
2. \<stmt\>
3. \<expr\>
4. \<var\>
5. \<digit\>

For FIRST(\<morestmts\>), we have FIRST+(\; \<stmtlist\>) and FIRST+($\epsilon$).

FIRST+(; \<stmtlist\>) = {;}
FIRST+($\epsilon$) = $\{\epsilon\} \cap \text{FOLLOW(morestmts)} = \{\epsilon,\text{end}\}$ 
The intersection of these two sets is $\emptyset$.

For FIRST(\<stmt\>), we have FIRST+(\<assign\>), FIRST+(\<ifstmt\>), FIRST+(\<repeatsmt\>), FIRST+(\<block\>)

FIRST+(\<assign\>) = FIRST(\<assign\>) = {a,b,c}
FIRST+(\<ifstmt\>) = FIRST(\<ifstmt\>) = {if}
FIRST+(\<repeatstmt\>) = FIRST(\<repeatstmt\>) = {repeat}
FIRST+(\<block\>) = FIRST(\<block\>) = {prog}
The intersection of these 5 sets is $\emptyset$.

For FIRST(\<expr\>), we have FIRST+(+ \<expr\> \<expr\>), FIRST+(- \<expr\> \<expr\>),  FIRST+(\* \<expr\> \<expr\>), FIRST+(\<var\>), FIRST+(\<digit\>)

FIRST+(+ \<expr\> \<expr\>) = {+}
FIRST+(- \<expr\> \<expr\>) = {-}
FIRST+(\* \<expr\> \<expr\>) = {\*}
FIRST+(\<var\>) = {a, b, c}
FIRST+(\<digit\>) = {0, 1, 2}
The intersection of these 5 sets is $\emptyset$.

For FIRST(\<var\>), we have FIRST+(a), FIRST+(\<b\>), FIRST+(\<c\>).

FIRST+(a) = {a}
FIRST+(b) = {b}
FIRST+(c) = {c}
The intersetion of these 3 sets is $\emptyset$.

For FIRST(\<digit\>), we have FIRST+(\<0\>), FIRST+(\<1\>), FIRST+(\<2\>).

FIRST+(0) = {0}
FIRST+(1) = {1}
FIRST+(2) = {2}
The intersection of these 3 sets is $\emptyset$.

$\blacksquare$ since all of the intersections of the sets are $\emptyset$, we know that the grammar above is LL(1).


2. Show the LL(1) parse table.
![[Pasted image 20230220234734.png]]

3. Write a recursive descent parser for the above grammar imperative C-like pseudo code as used in class (see lecture 9).

```c

main: {
	int num_operators = 0;
	token := next_token();
	if (<program>) && token == eof)
		print("accept");
	else
		print("error");
	printf("%d binary operators",num_operatorsz)
}

bool <program>:
	switch (token) {
		case prog:
			token := next_token();
			if (not <block>()) return false;
			if (token == ".") {
				token := next_token();
			}
			break;
		default: return false;
	}

bool <block>:
	switch (token){
		case begin:
			token := next_token();
			if (not <stmtlist>()) return false;
			if (token == end) {
				token := next_token();
			}
			break;
		default: return false;
	}

bool <stmtlist>{
	token := next_token();
	if (not <stmt>()) return false;
	token := next_token();
	if (not <morestmts>()) return false;
}

bool <morestmts>:
	switch (token){
		case ";":
			continue;
		case "epsilon":
			break;
		default: return false;
	}

bool <stmt>:
	switch (token){
		case "a":
		case "b":
		case "c":
			if (not <assign>()) return false;
			token := next_token();
			break;
		case "if":
			if (not <ifstmt>()) return false;
			token := next_token();
			break;
		case "repeat":
			if (not <repeatstmt>()) return false;
			token := next_token();
			break;
		case "begin":
			token := next_token();
			if (not <block>()) return false;
			break;
		default: return false;
	}

bool <assign>:
	switch (token){
		case "a":
		case "b":
		case "c":
			if (not <var>()) return false;
			token := next_token();
			if (token != "=") return false;
			token := next_token();
			if (not <expr>()) return false;
			break;
		default: return false;
	}

bool <ifstmt>:
	switch (token){
		case "if":
			token := next_token();
			if (not <testexpr>()) return false;
			token := next_token();
			if (token != "then") return false;
			token := next_token();
			if (not <stmt>()) return false;
			token := next_token();
			if (token != "else") return false;
			if (not <stmt>()) return false;
			break;
		default: return false;
	}

bool <repeatstmt>:
	switch (token){
		case "repeat":
			token := next_token();
			if (not <stmt>()) return false;
			token := next_token();
			if (token != "until") return false;
			token := next_token();
			if (not <textexpr>()) return false;
			break;
		default: return false;
	}

bool <testexpr>:
	switch (token){
		case a:
		case b:
		case c:
			if (not <var>()) return false;
			token := next_token();
			if (token != "<") return false;
			token := next_token();
			if (token != "=") return false
			token := next_token();
			if (not <expr>()) return false;
			num_operators++;
			break;
		default: return false;
	}

bool <expr>:
	switch (token){
		case "+":
		case "-":
		case "*":
			token := next_token();
			if (not <expr>()) return false;
			token := next_token();
			if (not <expr>()) return false;
			num_operators++;
			break;
		case "a":
		case "b":
		case "c":
			if (not <var>()) return false;
			token := next_token();
			break;
		case "0":
		case "1":
		case "2":
			if (not <digit>()) return false;
			token := next_token();
			break;
		default: return false;
	}

bool <var>:
	switch (token){
		case "a":
		case "b":
		case "c":
			break;
		default: return false;
	}

bool <digit>:
	switch (token){
		case 0:
		case 1:
		case 2:
			break;
		default: return false;
	}
```

4. Extend your recursive descent parser such that it prints the total number of binary operators (+, -, \*, <=) in the program. For the program listed below, your parser should print '7 binary operators'

```
program
begin
	if (b <=) then
		begin
			a = * a + b c
		end
		c = + a b
	else
		repeat
		begin
			a = + a b;
			c = - a 1
		end
		until a <= 1
end.
```